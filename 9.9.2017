
import time
def int_from_bin(data=''):
    return sum([int(data[::-1][x])*2**x for x in range(0, len(data))])
def get_boxes(length = 1):
    data = ''.join(['0' for i in range(length)])
    return [data[:-int(len(str(i)))]+str(i) for i in range(int(data.replace('0', '9'))+1)]
start_time = time.time()
print(get_boxes(10))
end_time = time.time()
print("Taken Time To Perform This: ", end_time - start_time)

def Approximating_Area(function="", lower_boundery=0, upper_boundery=0, ns=0, variable = "x"):
    if bool(function) and bool(upper_boundery) and bool(ns):
        width = float(upper_boundery-lower_boundery)/ns
        area = 0
        n = lower_boundery
        n1 = lower_boundery + width
        while n1 <= upper_boundery:
            x = float(n+n1)/2
            area += width * eval(function.replace("x", str(x)))
            n = n1
            n1 = n + width
        return "{0:.5f}".format(area)
        
def Prime_Number(n=0):
    'This Will Print The Prime Numbers After 2,3'
    for i in range(1, n):
        next_Prime_Number = (4*i)+1
        Is_Prime = False
        for q in range(2, next_Prime_Number):
            if next_Prime_Number % q == 0:
                Is_Prime = False
                break
            elif next_Prime_Number % q != 0 and q == next_Prime_Number-1:
                Is_Prime = True
        if Is_Prime:
            print("Order:[" + str(i)+"]", next_Prime_Number, "This Is Prime Number")
    return "Done"
    
def D3_matrix_det(matrix=[[], []]):
    row_len = [len(x) for x in matrix]
    order = row_len[0] if row_len[0] == matrix.__len__() else 0
    offset = 0
    main_matrix_val = 0
    if order:
        for i in matrix[0]:
            val = int(i) * (-1) ** offset
            num = [i]
            for j in matrix[1:]:
                num.append(j[:offset] + j[offset + 1:])
            if num[1:].__len__() == 2:
                num = num[1:]
                val *= (int(num[0][0]) * int(num[1][1])) - (int(num[0][1]) * int(num[1][0]))
                main_matrix_val += val
            else:
                main_matrix_val += val * D3_matrix_det(num[1:])
            offset += 1
    return main_matrix_val

def factorial(num=0):
    while num != 0:
        return num * factorial(num-1)
    return 1
    
def sort(L=[], reverse=False):
    return [int(x) if x.isnumeric() else x for x in sorted([str(x) for x in L], reverse=reverse)]

def max(numbers=[]):
    max_number_offset = 0
    for i in range(len(numbers)-1):
        if numbers[max_number_offset] < numbers[i]:
            max_number_offset = i
    return numbers[max_number_offset]
