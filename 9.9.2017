class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
def find_prime_kPerm(n, kPerm):
    from itertools import permutations as perm
    def is_prime(number):
        for i in range(2, number):
            if number % i == 0 and not number == 2:
                return False
        return True
    primes = [x for x in range(12, n+1) if is_prime(x)]
    res = []
    for i in primes:
        required_perm = [int(''.join(list(x))) for x in perm(str(i))]
        required_perm = [x for x in required_perm if is_prime(x) and x != i and len(str(x)) == len(str(i))]
        if len(required_perm) == kPerm:
            res += [i]
    if len(res) == 0:
        return [0, 0, 0]
    else:
        return [len(res), min(res), max(res)]

def skrzat(base, number):
    if base == 'b':
        number = number[::-1]
        decoded_number = 0
        for i in range(len(number)):
            decoded_number += ((-2)**i) * int(number[i])
        return 'From binary: %s is %s' % (number[::-1], decoded_number)
    elif base == 'd':
        x = number
        if number == 0:
            return "0"
        converted_number = ""
        while number != 0:
            remainder = number % -2
            number //= -2
            if remainder < 0:
                remainder += 2
                number += 1
            converted_number += str(abs(remainder))
        return "From decimal: %s is %s" % (x, converted_number[::-1])
    else:
        return None
    pass
def knights_tour(start, size):
    import time, copy

    def make_board(size):
        return {(x, y): 0 for x in range(1, size+1) for y in range(1, size+1)}
    my_board = make_board(size)
    my_board[tuple(start)] = 1
    moves = [tuple(start)]
    next_move = start
    knight_moves = ((1, 2), (-1, 2), (2, 1), (-2, 1), (2, -1), (-2, -1), (-1, -2), (1, -2))

    def make_string_from_board(my_board):
        board = []
        for row in range(size):
            board += [[]]
            for column in range(size):
                board[row] += [my_board[(column+1, row+1)]]
        return board
    def avail_moves(point, board):
        return set((point[0]+_x, point[1]+_y) for _x, _y in knight_moves if (1 <= point[0]+_x <= size
                   and 1 <= point[1]+_y <= size) and not board[(point[0]+_x, point[1]+_y)])
    counter = 0

    def accessability(move):
        access = []
        board = copy.deepcopy(my_board)
        for position in avail_moves(move, board):
            board[position] = 1
            access.append((len(avail_moves(position, board)), position))
            board[position] = 0
        return access
    while counter < size * size:
        if accessability(next_move):
            next_move = min(accessability(next_move))[1]
            my_board[next_move] = 1
            moves += [next_move]
            counter += 1
        else:
            break
    print(*make_string_from_board(my_board))
    return moves



print(knights_tour([1, 1], 6))


def sorting_algorithm(lst):
    main_list = []; [main_list.append(x) for x in lst if not x in main_list]
    sorted_array = []
    while main_list:
        smallest_number = main_list[0]
        for number in main_list[1:]:
            if number < smallest_number:
                smallest_number = number
        main_list.remove(smallest_number)
        sorted_array += [smallest_number]
    return sorted_array
def simple_assembler(program):
    to_be_excuted = [line.split(" ") for line in program.split("\n")]
    Done = []
    enteries = {}
    nov = lambda x: int(x) if str(x).replace("-", "").isnumeric() else int(enteries[x])
    while to_be_excuted:
        excuting = to_be_excuted.pop(0)
        Done += [excuting]
        if excuting[0] == "mov":
            enteries[excuting[1]] = nov(excuting[2])
        elif excuting[0] == "inc":
            enteries[excuting[1]] += 1
        elif excuting[0] == "dec":
            enteries[excuting[1]] -= 1
        elif excuting[0] == "jnz":
            if nov(excuting[2]) < 0:
                if enteries[excuting[1]] > 0:
                    to_be_excuted = Done[int(nov(excuting[2]))-1:] + to_be_excuted
                    Done = Done[:int(nov(excuting[2]))-1]
                else:
                    continue
            else:
                to_be_excuted = to_be_excuted[int(nov(excuting[2])):]
    return enteries 
def brainfuck_to_c(source_code):
    if source_code.count("[") == source_code.count("]"):
        while source_code.count("[]") > 0:
            source_code = source_code.replace("[]", "")
        data = dict(); identifier = 0; counter = 0
        for char in source_code:
            if char == "+" or char == '-' or char == '>' or char == '<':
                if counter != 0 and char != source_code[counter - 1]:
                    identifier += 1
                if (str(identifier), char) in data.keys():
                    data[(str(identifier), char)] += str(identifier)
                else:
                    data[(str(identifier), char)] = str(identifier)
            else:
                if (str(identifier), char) not in data.keys():
                    data[(str(identifier), char)] = str(identifier)
                else:
                    data[(str(identifier), char)] += str(identifier)
                    pass
                identifier += 1
            counter += 1
        def replacer(dictionary):
            translate_code = ""
            for (key, value) in dictionary.items():
                if key[1] == "+":
                    translate_code += "*p += %d;\n" % value.count(key[0])
                elif key[1] == '>':
                    translate_code += "p += %d;\n" % value.count(key[0])
                elif key[1] == '-':
                    translate_code += "*p -= %d;\n" % value.count(key[0])
                elif key[1] == '<':
                    translate_code += "p -= %d;\n" % value.count(key[0])
                elif key[1] == '.':
                    translate_code += "putchar(*p);\n"
                elif key[1] == ',':
                    translate_code += "*p = getchar();\n"
                elif key[1] == '[':
                    translate_code += "if (*p) do {\n"
                elif key[1] == ']':
                    translate_code += "} while (*p);\n"
            return translate_code
        return replacer(data)
    else:
        return "Error!"

print(brainfuck_to_c("++++[.++--]"))


def biggest_triang_int(point_list, center, radius):
    try:
        import itertools
        vector_formulation = lambda a, b: (b[0]-a[0], b[1]-a[1], b[2]-a[2])
        cross_product = lambda a, b: (a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0])
        vector_magnitude = lambda x,y,z: ((x**2)+(y**2)+(z**2))**(0.5)
        inside_check = lambda p: True if vector_magnitude(*vector_formulation(center, p)) <= radius else False
        triangle_area = lambda vector1, vector2: vector_magnitude(*cross_product(vector1, vector2))*0.5
        areas = []; areas_combination = []; points = [(x) for x in point_list if inside_check(x)]
        for combination in list(itertools.combinations(points, 3)):
            vector1 = vector_formulation(combination[0], combination[1])
            vector2 = vector_formulation(combination[0], combination[2])
            area = triangle_area(vector1, vector2)
            areas += [area]
            areas_combination += [(combination, area)]
        max_area = max(areas)
        res = []
        for x in areas_combination:
            if x[1] == max_area:
                res += [list(x[0])]
        if len(res) <= 1:
            return [len(areas), max_area, res[0]]
        else:
            return [len(areas), max_area, res]
    except:
            return []
def intersction(*seq):
    return list(set([x for x in seq[0] for q in seq[1:] if x in q ]))
def biggest_triang_int(point_list, center, radius):
    import itertools
    vector_formulation = lambda a, b: (b[0]-a[0], b[1]-a[1], b[2]-a[2])
    cross_product = lambda a, b: (a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0])
    vector_magnitude = lambda x,y,z: ((x**2)+(y**2)+(z**2))**(0.5)
    inside_check = lambda p: True if vector_magnitude(*vector_formulation(center, p)) <= radius else False
    triangle_area = lambda vector1, vector2: vector_magnitude(*cross_product(vector1, vector2))*0.5
    areas = []
    for combination in list(itertools.combinations([(x) for x in point_list if inside_check(x)], 3)):
        vector1 = vector_formulation(combination[0], combination[1])
        vector2 = vector_formulation(combination[0], combination[2])
        areas += [triangle_area(vector1, vector2)]
    return max(areas)
class file_manager:
    import os
    def __init__(self, path):
        self.data = self.__Tree_dscanner(path)
        pass
    def __Tree_dscanner(self, path):
        data = {path:[]}
        for i in os.listdir(path):
            if os.path.isdir(i):
                data.update(self.__Tree_dscanner(i))
            else:
                data[path] += [i]
        return data
    def printpath(self):
        readable_data = ""
        for key in self.data:
            parser = "\n"
            for val in self.data[key]:
                parser += "   -"+str(val)+"\n"
            readable_data += "--dir ["+str(key)+"]"+parser
        return readable_data
    
class Infix:
    def __init__(self, function):
        self.function = function
    def __ror__(self, other):
        return Infix(lambda x, self=self, other=
