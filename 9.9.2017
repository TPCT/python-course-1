class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
def simple_assembler(program):
    to_be_excuted = [line.split(" ") for line in program.split("\n")]
    Done = []
    enteries = {}
    nov = lambda x: int(x) if str(x).replace("-", "").isnumeric() else int(enteries[x])
    while to_be_excuted:
        excuting = to_be_excuted.pop(0)
        Done += [excuting]
        if excuting[0] == "mov":
            enteries[excuting[1]] = nov(excuting[2])
        elif excuting[0] == "inc":
            enteries[excuting[1]] += 1
        elif excuting[0] == "dec":
            enteries[excuting[1]] -= 1
        elif excuting[0] == "jnz":
            if nov(excuting[2]) < 0:
                if enteries[excuting[1]] > 0:
                    to_be_excuted = Done[int(nov(excuting[2]))-1:] + to_be_excuted
                    Done = Done[:int(nov(excuting[2]))-1]
                else:
                    continue
            else:
                to_be_excuted = to_be_excuted[int(nov(excuting[2])):]
    return enteries 
def brainfuck_to_c(source_code):
    if source_code.count("[") == source_code.count("]"):
        while source_code.count("[]") > 0:
            source_code = source_code.replace("[]", "")
        data = dict(); identifier = 0; counter = 0
        for char in source_code:
            if char == "+" or char == '-' or char == '>' or char == '<':
                if counter != 0 and char != source_code[counter - 1]:
                    identifier += 1
                if (str(identifier), char) in data.keys():
                    data[(str(identifier), char)] += str(identifier)
                else:
                    data[(str(identifier), char)] = str(identifier)
            else:
                if (str(identifier), char) not in data.keys():
                    data[(str(identifier), char)] = str(identifier)
                else:
                    data[(str(identifier), char)] += str(identifier)
                    pass
                identifier += 1
            counter += 1
        def replacer(dictionary):
            translate_code = ""
            for (key, value) in dictionary.items():
                if key[1] == "+":
                    translate_code += "*p += %d;\n" % value.count(key[0])
                elif key[1] == '>':
                    translate_code += "p += %d;\n" % value.count(key[0])
                elif key[1] == '-':
                    translate_code += "*p -= %d;\n" % value.count(key[0])
                elif key[1] == '<':
                    translate_code += "p -= %d;\n" % value.count(key[0])
                elif key[1] == '.':
                    translate_code += "putchar(*p);\n"
                elif key[1] == ',':
                    translate_code += "*p = getchar();\n"
                elif key[1] == '[':
                    translate_code += "if (*p) do {\n"
                elif key[1] == ']':
                    translate_code += "} while (*p);\n"
            return translate_code
        return replacer(data)
    else:
        return "Error!"

print(brainfuck_to_c("++++[.++--]"))


def biggest_triang_int(point_list, center, radius):
    try:
        import itertools
        vector_formulation = lambda a, b: (b[0]-a[0], b[1]-a[1], b[2]-a[2])
        cross_product = lambda a, b: (a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0])
        vector_magnitude = lambda x,y,z: ((x**2)+(y**2)+(z**2))**(0.5)
        inside_check = lambda p: True if vector_magnitude(*vector_formulation(center, p)) <= radius else False
        triangle_area = lambda vector1, vector2: vector_magnitude(*cross_product(vector1, vector2))*0.5
        areas = []; areas_combination = []; points = [(x) for x in point_list if inside_check(x)]
        for combination in list(itertools.combinations(points, 3)):
            vector1 = vector_formulation(combination[0], combination[1])
            vector2 = vector_formulation(combination[0], combination[2])
            area = triangle_area(vector1, vector2)
            areas += [area]
            areas_combination += [(combination, area)]
        max_area = max(areas)
        res = []
        for x in areas_combination:
            if x[1] == max_area:
                res += [list(x[0])]
        if len(res) <= 1:
            return [len(areas), max_area, res[0]]
        else:
            return [len(areas), max_area, res]
    except:
            return []
def intersction(*seq):
    return list(set([x for x in seq[0] for q in seq[1:] if x in q ]))
def biggest_triang_int(point_list, center, radius):
    import itertools
    vector_formulation = lambda a, b: (b[0]-a[0], b[1]-a[1], b[2]-a[2])
    cross_product = lambda a, b: (a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0])
    vector_magnitude = lambda x,y,z: ((x**2)+(y**2)+(z**2))**(0.5)
    inside_check = lambda p: True if vector_magnitude(*vector_formulation(center, p)) <= radius else False
    triangle_area = lambda vector1, vector2: vector_magnitude(*cross_product(vector1, vector2))*0.5
    areas = []
    for combination in list(itertools.combinations([(x) for x in point_list if inside_check(x)], 3)):
        vector1 = vector_formulation(combination[0], combination[1])
        vector2 = vector_formulation(combination[0], combination[2])
        areas += [triangle_area(vector1, vector2)]
    return max(areas)
class file_manager:
    import os
    def __init__(self, path):
        self.data = self.__Tree_dscanner(path)
        pass
    def __Tree_dscanner(self, path):
        data = {path:[]}
        for i in os.listdir(path):
            if os.path.isdir(i):
                data.update(self.__Tree_dscanner(i))
            else:
                data[path] += [i]
        return data
    def printpath(self):
        readable_data = ""
        for key in self.data:
            parser = "\n"
            for val in self.data[key]:
                parser += "   -"+str(val)+"\n"
            readable_data += "--dir ["+str(key)+"]"+parser
        return readable_data
    
class Infix:
    def __init__(self, function):
        self.function = function
    def __ror__(self, other):
        return Infix(lambda x, self=self, other=other: self.function(other, x))
    def __or__(self, other):
        return self.function(other)
    def __rlshift__(self, other):
        return Infix(lambda x, self=self, other=other: self.function(other, x))
    def __rshift__(self, other):
        return self.function(other)
    def __call__(self, value1, value2):
        return self.function(value1, value2)    
def minmax(compare, *data):
    res = data[0]
    for i in data[1:]:
        if not compare(res, i):
            res = i
    return res
    
import time
def int_from_bin(data=''):
    return sum([int(data[::-1][x])*2**x for x in range(0, len(data))])
def get_boxes(length = 1):
    data = ''.join(['0' for i in range(length)])
    return [data[:-int(len(str(i)))]+str(i) for i in range(int(data.replace('0', '9'))+1)]
start_time = time.time()
print(get_boxes(10))
end_time = time.time()
print("Taken Time To Perform This: ", end_time - start_time)

def bintoint(bincode=""):
    num = 0
    bincode = bincode[::-1]
    for i in range(len(bincode)):
        num += (int(bincode[i]))*(2**int(i))
    return num
def Approximating_Area(function="", lower_boundery=0, upper_boundery=0, ns=0, variable = "x"):
    if bool(function) and bool(upper_boundery) and bool(ns):
        width = float(upper_boundery-lower_boundery)/ns
        area = 0
        n = lower_boundery
        n1 = lower_boundery + width
        while n1 <= upper_boundery:
            x = float(n+n1)/2
            area += width * eval(function.replace("x", str(x)))
            n = n1
            n1 = n + width
        return "{0:.5f}".format(area)
        
def Prime_Number(n=0):
    'This Will Print The Prime Numbers After 2,3'
    for i in range(1, n):
        next_Prime_Number = (4*i)+1
        Is_Prime = False
        for q in range(2, next_Prime_Number):
            if next_Prime_Number % q == 0:
                Is_Prime = False
                break
            elif next_Prime_Number % q != 0 and q == next_Prime_Number-1:
                Is_Prime = True
        if Is_Prime:
            print("Order:[" + str(i)+"]", next_Prime_Number, "This Is Prime Number")
    return "Done"
    
def D3_matrix_det(matrix=[[], []]):
    row_len = [len(x) for x in matrix]
    order = row_len[0] if row_len[0] == matrix.__len__() else 0
    offset = 0
    main_matrix_val = 0
    if order:
        for i in matrix[0]:
            val = int(i) * (-1) ** offset
            num = [i]
            for j in matrix[1:]:
                num.append(j[:offset] + j[offset + 1:])
            if num[1:].__len__() == 2:
                num = num[1:]
                val *= (int(num[0][0]) * int(num[1][1])) - (int(num[0][1]) * int(num[1][0]))
                main_matrix_val += val
            else:
                main_matrix_val += val * D3_matrix_det(num[1:])
            offset += 1
    return main_matrix_val

def factorial(num=0):
    while num != 0:
        return num * factorial(num-1)
    return 1
    
def sort(L=[], reverse=False):
    return [int(x) if x.isnumeric() else x for x in sorted([str(x) for x in L], reverse=reverse)]

def max_number(numbers = []):
    max = 0
    for i in range(len(numbers)):
        if numbers[i] >= numbers[-(i+1)] and numbers[i] >= max:
            max = numbers[i]
        elif numbers[-(i+1)] >= numbers[i] and numbers[-(i+1)] >= max:
            max = numbers[-(i+1)]
        else:
            pass
    return max
            
def factorial_modified(num=0):
    res = 1
    while num != 0:
        res *= num
        num -=1
    return res

def reverse(data=[]):
    rev_arr = []
    for i in range(len(data)-1, -1, -1):
        rev_arr += [data[i]]
    return rev_arr
    
def Dict_sort(dictionary={}):
    return dict(zip(sorted(dictionary), [dictionary[x] for x in sorted(dictionary)]))
