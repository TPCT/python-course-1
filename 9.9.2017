def get_roots(eqn):
    from fractions import Fraction; from string import ascii_letters; from itertools import chain
    main_variable, eqn = set([x for x in eqn if x in ascii_letters]),\
                         eqn.replace(' ', '').replace('-', '+-').replace('^', '**').replace('(', '').replace(')', '').split('+')
    if len(main_variable) > 1: return "This Is Multi-Variable Equation"
    elif len(main_variable) == 0: return "This Is Not Valid Equation"
    main_variable = list(main_variable)[0]
    equation = '+'.join(['(' + i.split(main_variable)[0] + "*(%s)" % main_variable + ''.join(i.split(main_variable)[1:]) + ')'
                                                      if len(i.split(main_variable)[0]) > 0 and len(i.split(main_variable)) > 1 and i.split(main_variable)[0][-1] != '*' and i.split(main_variable)[0][-1] != '-'
                                                      else '(' + '(%s)**' %(i.split('**')[0]) + ''.join(i.split('**')[1:]) + ')'
                                                      if len(i.split('**')) > 1 else '(' + '(%s)' %(i.split('**')[0])+ ')'  for i in eqn])
    max_power = max([int(q.replace('(', '').replace(')', '').split('**')[1]) for q in eqn if q.count('**') > 0])
    max_power_coffient, free_term, divisors, first_power_coffient = Fraction.from_float(float([x.split(main_variable)[0] if main_variable+'**'+ str(max_power)
                                   in x.replace('(','').replace(')', '') and len(x.split(main_variable)[0]) > 0 else 1
                                   for x in eqn][0])).limit_denominator(),\
                                   Fraction.from_float(float([x for x in eqn if x.replace('.', '').replace('-','').isnumeric()][0])).limit_denominator(),\
                                   lambda number: [n for n in range(1, int(abs(number))+1) if number % n == 0],\
                                   [Fraction.from_float(float(x.split(main_variable)[0])) for x in eqn if x.count(main_variable) == 1 and len(x.split(main_variable)[1]) == 0]
    first_power_coffient = first_power_coffient[0] if first_power_coffient else 0
    if max_power == 2:
        dis = (first_power_coffient ** 2) - 4*(free_term)*(max_power_coffient)
        dis = (dis)**0.5 if dis >= 0 else None
        return ("There Are Two Roots: %s, %s" %(str(Fraction.from_float(((-first_power_coffient)- dis)/(2*max_power_coffient))), str(Fraction.from_float(((-first_power_coffient)+dis)/(2*max_power_coffient))))
                if dis > 0 else "There's Only One Root: %s" % str((-first_power_coffient)/(2*max_power_coffient))) if dis != None else "There's No Real Roots"
    max_power_coffient_divisors, free_term_divisors = divisors(max_power_coffient), divisors(free_term)
    roots = sum([[float(i/n), float(-i/n)] if not float(eval(equation.replace(main_variable, str(i/n)))) else [float(-i/n)]
                      if not float(eval(equation.replace(main_variable, str(-i/n))))
                      else i/n if not float(eval(equation.replace(main_variable, str(i/n)))) else []
                      for i in free_term_divisors for n in max_power_coffient_divisors], [])
    return "The Roots: %s" % ', '.join(list(map(str, map(Fraction.from_float, roots))))  if len(roots) > 0 else "There's No Roots"
def get_line_eqn(point1, point2):
    point1, point2 = tuple(int(x) for x in point1.split(',')), tuple(int(x) for x in point2.split(','))
    slope = (point2[1] - point1[1])/(point2[0] - point1[0]) if point2[0] - point1[0] != 0 else "undefined"
    if slope != 'undefined':
        intercept = (slope*point1[0]) + point1[1]
        slope_intercept_eqn = "Y = %sx + %s" % (slope, intercept)
        point_slope_eqn = "Y = (%s)(x-%s) + %s" %(slope, point1[0], point1[1])
        return "slope: %s\nslope intercept equation:%s\npoint slope equation:%s" % (slope, slope_intercept_eqn, point_slope_eqn)
    else:
        return "slope: undefined\nequation of line: x=%s" % point1[0]
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
primes = lambda n: [x for x in range(2, n+1) if x >= 2 and (len([x for check in range(2, x) if (x % check == 0 and check != x)]) == 0)]
def interpreter(code, tape):
    result = tape
    def icot(code=code):
        opening_tag = dict()
        op_tag = []
        sub_counter = 0
        for command in code:
            if command == '[':
                op_tag += [sub_counter]
            elif command == ']':
                opening_tag[op_tag.pop()] = sub_counter
            sub_counter += 1
        return opening_tag
    tape_counter = 0
    command_counter = 0
    command_freeze = False
    tags = icot()
    while 0 <= tape_counter < len(tape) and 0 <=  command_counter < len(code):
        command = code[command_counter]
        if command == '>':
            command_counter += 1
            tape_counter += 1
        elif command == '<':
            command_counter += 1
            tape_counter -= 1
        elif command == '*':
            if 0 <= tape_counter < len(result):
                result = list(result)
                if result[tape_counter] == '0':
                    result[tape_counter] = '1'
                else:
                    result[tape_counter] = '0'
                result = ''.join(result)
            else:
                return result
            command_counter += 1
        elif command == '[':
            tags[tags[command_counter]] = command_counter
            if result[tape_counter] == '0':
                command_counter = tags[command_counter]
            else:
                command_counter += 1
        elif command == ']':
            if result[tape_counter] == '1':
                command_counter = tags[command_counter]
            else:
                command_counter += 1
        else:
            command_counter += 1
    return result
def find_prime_kPerm(n, kPerm):
    from itertools import permutations as perm
    def is_prime(number):
        for i in range(2, number):
            if number % i == 0 and not number == 2:
                return False
        return True
    primes = [x for x in range(12, n+1) if is_prime(x)]
    res = []
    for i in primes:
        required_perm = [int(''.join(list(x))) for x in perm(str(i))]
        required_perm = [x for x in required_perm if is_prime(x) and x != i and len(str(x)) == len(str(i))]
        if len(required_perm) == kPerm:
            res += [i]
    if len(res) == 0:
        return [0, 0, 0]
    else:
        return [len(res), min(res), max(res)]

def skrzat(base, number):
    if base == 'b':
        number = number[::-1]
        decoded_number = 0
        for i in range(len(number)):
            decoded_number += ((-2)**i) * int(number[i])
        return 'From binary: %s is %s' % (number[::-1], decoded_number)
    elif base == 'd':
        x = number
        if number == 0:
            return "0"
        converted_number = ""
        while number != 0:
            remainder = number % -2
            number //= -2
            if remainder < 0:
                remainder += 2
                number += 1
            converted_number += str(abs(remainder))
        return "From decimal: %s is %s" % (x, converted_number[::-1])
    else:
        return None
    pass
def knights_tour(start, size):
    import time, copy

    def make_board(size):
        return {(x, y): 0 for x in range(1, size+1) for y in range(1, size+1)}
    my_board = make_board(size)
    my_board[tuple(start)] = 1
    moves = [tuple(start)]
    next_move = start
    knight_moves = ((1, 2), (-1, 2), (2, 1), (-2, 1), (2, -1), (-2, -1), (-1, -2), (1, -2))

    def make_string_from_board(my_board):
        board = []
        for row in range(size):
            board += [[]]
            for column in range(size):
                board[row] += [my_board[(column+1, row+1)]]
        return board
    def avail_moves(point, board):
        return set((point[0]+_x, point[1]+_y) for _x, _y in knight_moves if (1 <= point[0]+_x <= size
                   and 1 <= point[1]+_y <= size) and not board[(point[0]+_x, point[1]+_y)])
    counter = 0

    def accessability(move):
        access = []
        board = copy.deepcopy(my_board)
        for position in avail_moves(move, board):
            board[position] = 1
            access.append((len(avail_moves(position, board)), position))
            board[position] = 0
        return access
    while counter < size * size:
        if accessability(next_move):
            next_move = min(accessability(next_move))[1]
            my_board[next_move] = 1
            moves += [next_move]
            counter += 1
        else:
            break
    print(*make_string_from_board(my_board))
    return moves



print(knights_tour([1, 1], 6))


def sorting_algorithm(lst):
    main_list = []; [main_list.append(x) for x in lst if not x in main_list]
    sorted_array = []
    while main_list:
        smallest_number = main_list[0]
        for number in main_list[1:]:
            if number < smallest_number:
                smallest_number = number
        main_list.remove(smallest_number)
        sorted_array += [smallest_number]
    return sorted_array
def simple_assembler(program):
    to_be_excuted = [line.split(" ") for line in program.split("\n")]
    Done = []
    enteries = {}
    nov = lambda x: int(x) if str(x).replace("-", "").isnumeric() else int(enteries[x])
    while to_be_excuted:
        excuting = to_be_excuted.pop(0)
        Done += [excuting]
        if excuting[0] == "mov":
            enteries[excuting[1]] = nov(excuting[2])
        elif excuting[0] == "inc":
            enteries[excuting[1]] += 1
        elif excuting[0] == "dec":
            enteries[excuting[1]] -= 1
        elif excuting[0] == "jnz":
            if nov(excuting[2]) < 0:
                if enteries[excuting[1]] > 0:
                    to_be_excuted = Done[int(nov(excuting[2]))-1:] + to_be_excuted
                    Done = Done[:int(nov(excuting[2]))-1]
                else:
                    continue
            else:
                to_be_excuted = to_be_excuted[int(nov(excuting[2])):]
    return enteries 
def brainfuck_to_c(source_code):
    if source_code.count("[") == source_code.count("]"):
        while source_code.count("[]") > 0:
            source_code = source_code.replace("[]", "")
        data = dict(); identifier = 0; counter = 0
        for char in source_code:
            if char == "+" or char == '-' or char == '>' or char == '<':
                if counter != 0 and char != source_code[counter - 1]:
                    identifier += 1
                if (str(identifier), char) in data.keys():
                    data[(str(identifier), char)] += str(identifier)
                else:
                    data[(str(identifier), char)] = str(identifier)
            else:
                if (str(identifier), char) not in data.keys():
                    data[(str(identifier), char)] = str(identifier)
                else:
                    data[(str(identifier), char)] += str(identifier)
                    pass
                identifier += 1
            counter += 1
        def replacer(dictionary):
            translate_code = ""
            for (key, value) in dictionary.items():
                if key[1] == "+":
                    translate_code += "*p += %d;\n" % value.count(key[0])
                elif key[1] == '>':
                    translate_code += "p += %d;\n" % value.count(key[0])
                elif key[1] == '-':
                    translate_code += "*p -= %d;\n" % value.count(key[0])
                elif key[1] == '<':
                    translate_code += "p -= %d;\n" % value.count(key[0])
                elif key[1] == '.':
                    translate_code += "putchar(*p);\n"
                elif key[1] == ',':
                    translate_code += "*p = getchar();\n"
                elif key[1] == '[':
                    translate_code += "if (*p) do {\n"
                elif key[1] == ']':
                    translate_code += "} while (*p);\n"
            return translate_code
        return replacer(data)
    else:
        return "Error!"

print(brainfuck_to_c("++++[.++--]"))


def biggest_triang_int(point_list, center, radius):
    try:
        import itertools
        vector_formulation = lambda a, b: (b[0]-a[0], b[1]-a[1], b[2]-a[2])
        cross_product = lambda a, b: (a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0])
        vector_magnitude = lambda x,y,z: ((x**2)+(y**2)+(z**2))**(0.5)
        inside_check = lambda p: True if vector_magnitude(*vector_formulation(center, p)) <= radius else False
        triangle_area = lambda vector1, vector2: vector_magnitude(*cross_product(vector1, vector2))*0.5
        areas = []; areas_combination = []; points = [(x) for x in point_list if inside_check(x)]
        for combination in list(itertools.combinations(points, 3)):
            vector1 = vector_formulation(combination[0], combination[1])
            vector2 = vector_formulation(combination[0], combination[2])
            area = triangle_area(vector1, vector2)
            areas += [area]
            areas_combination += [(combination, area)]
        max_area = max(areas)
        res = []
        for x in areas_combination:
            if x[1] == max_area:
                res += [list(x[0])]
        if len(res) <= 1:
            return [len(areas), max_area, res[0]]
        else:
            return [len(areas), max_area, res]
    except:
            return []
def intersction(*seq):
    return list(set([x for x in seq[0] for q in seq[1:] if x in q ]))
def biggest_triang_int(point_list, center, radius):
    import itertools
    vector_formulation = lambda a, b: (b[0]-a[0], b[1]-a[1], b[2]-a[2])
    cross_product = lambda a, b: (a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0])
    vector_magnitude = lambda x,y,z: ((x**2)+(y**2)+(z**2))**(0.5)
    inside_check = lambda p: True if vector_magnitude(*vector_formulation(center, p)) <= radius else False
    triangle_area = lambda vector1, vector2: vector_magnitude(*cross_product(vector1, vector2))*0.5
    areas = []
    for combination in list(itertools.combinations([(x) for x in point_list if inside_check(x)], 3)):
        vector1 = vector_formulation(combination[0], combination[1])
        vector2 = vector_formulation(combination[0], combination[2])
        areas += [triangle_area(vector1, vector2)]
    return max(areas)
class file_manager:
    import os
    def __init__(self, path):
        self.data = self.__Tree_dscanner(path)
        pass
    def __Tree_dscanner(self, path):
        data = {path:[]}
        for i in os.listdir(path):
            if os.path.isdir(i):
                data.update(self.__Tree_dscanner(i))
            else:
                data[path] += [i]
        return data
    def printpath(self):
        readable_data = ""
        for key in self.data:
            parser = "\n"
            for val in self.data[key]:
                parser += "   -"+str(val)+"\n"
            readable_data += "--dir ["+str(key)+"]"+parser
        return readable_data
    
class Infix:
    def __init__(self, function):
        self.function = function
    def __ror__(self, other):
        return Infix(lambda x, self=self, other=

class matrix_operation:
    custom_map = lambda self, function, iterable, command: function(iterable, command)
    get_columns = lambda self, matrix:[[self.custom_map(lambda x,y: x[y], row, column) for row in matrix] for column in range(len(matrix[0]))]
    addition_operation = lambda self, matrix1, matrix2: [[matrix1[row][column] + matrix2[row][column] for column in range(len(matrix1[row]))] for row in range(len(matrix1))]
    subtraction_operation = lambda self, matrix1, matrix2: [[matrix1[row][column] - matrix2[row][column] for column in range(len(matrix1[row]))] for row in range(len(matrix1))]
    multiplication_operation = lambda self, main_matrix, columns: [[sum(list(map(lambda x,y: x*y, row, column))) for column in columns] for row in main_matrix]
    main_diagonal_elements = lambda self, matrix: [matrix[i][i] for i in range(len(matrix))]
    secondery_diagonal_elements = lambda self, matrix: [matrix[i-1][-i] for i in range(1, len(matrix)+1)]        
    def matrix_multiplication(self, M1,M2):
        columns = get_columns(M2)
        if len(columns[0]) == len(M1):
            return self.multiplication_operation(M1, columns)
        else:
            return "Parsing Matrix Error"
    def matrix_addition(self, M1, M2):
        if len(M1) == len(M2) and len(self.get_columns(M1)) == len(self.get_columns(M2)):
            return self.addition_operation(M1, M2)
        else:
            return "Parsing Matrix Error"
    def matrix_subtraction(self, M1, M2):
        if len(M1) == len(M2) and len(self.get_columns(M1)) == len(self.get_columns(M2)):
            return self.subtraction_operation(M1, M2)
        else:
            return "Parsing Matrix Error"
def loading_bar(length=10, time_sleep: 'millisecond'=100, shape1='*', shape2='-'):
    import time, sys
    progress_bar = ""
    for i in range(length+1):
        if i % 2 == 0:
            progress_bar = "[%s%s][%s" % (i, '%', shape1 * i)
        else:
            progress_bar = "[%s%s][%s" % (i, '%', shape2 * i)
        sys.stdout.write(progress_bar)
        sys.stdout.flush()
        if i < length-1:
            time.sleep(time_sleep * (1e-3))
            sys.stdout.write('\r')
            sys.stdout.flush()
        else:
            sys.stdout.write('\r')
            sys.stdout.flush()
            sys.stdout.write(progress_bar)
    sys.stdout.write(']')
loading_bar(100, 500, '|')
