import os, time
class File_Tree(object):
	import os

	def __init__(self, path, write_to_file = False, dest=os.path.join(os.path.dirname(__file__), str(time.localtime(time.time()).tm_mday))):
		self.data = ''
		if write_to_file:
			self.file_write = open(dest, 'a+')
			if len(self.file_write.read()) > 0:
				self.file_write.write('------------\n')
		self.init(path, 0, write_to_file)
		if 'file_write' in self.__dict__:
			self.file_write.close()

	def init(self, path, indent, write_to_file):
		if self.os.path.exists(path):
			if write_to_file:
				self.file_write.write('%s|_%s\n' % (' ' * indent, self.os.path.split(path)[-1]))
			print('%s|_%s' % (' ' * indent, self.os.path.split(path)[-1]))
			if not self.os.path.isdir(path):
				for i in self.os.listdir(path):
					self.init(self.os.path.join(path, i), indent + 3, write_to_file)
		else:
			return 'This Path Cannot Be Found'


if __name__ == '__main__':
	#tests
	File_Tree(os.path.dirname(__file__), True)
	File_Tree(os.path.realpath('/'), True)

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
primes = lambda n: [x for x in range(2, n+1) if x >= 2 and (len([x for check in range(2, x) if (x % check == 0 and check != x)]) == 0)]
def interpreter(code, tape):
    result = tape
    def icot(code=code):
        opening_tag = dict()
        op_tag = []
        sub_counter = 0
        for command in code:
            if command == '[':
                op_tag += [sub_counter]
            elif command == ']':
                opening_tag[op_tag.pop()] = sub_counter
            sub_counter += 1
        return opening_tag
    tape_counter = 0
    command_counter = 0
    command_freeze = False
    tags = icot()
    while 0 <= tape_counter < len(tape) and 0 <=  command_counter < len(code):
        command = code[command_counter]
        if command == '>':
            command_counter += 1
            tape_counter += 1
        elif command == '<':
            command_counter += 1
            tape_counter -= 1
        elif command == '*':
            if 0 <= tape_counter < len(result):
                result = list(result)
                if result[tape_counter] == '0':
                    result[tape_counter] = '1'
                else:
                    result[tape_counter] = '0'
                result = ''.join(result)
            else:
                return result
            command_counter += 1
        elif command == '[':
            tags[tags[command_counter]] = command_counter
            if result[tape_counter] == '0':
                command_counter = tags[command_counter]
            else:
                command_counter += 1
        elif command == ']':
            if result[tape_counter] == '1':
                command_counter = tags[command_counter]
            else:
                command_counter += 1
        else:
            command_counter += 1
    return result
def simple_game():
    import sys, os, random
    gamer_choice = input('please choose X or O to start: ')
    cells, non_used_cells = ['_' for x in range(9)], list(range(1, 10))
    available_choices, main_matrix = ['x', 'o'], []

    def print_matrix(data, length=3):
        import sys
        counter = 0
        main_board_string = ''
        for i in range(len(data)):
            if (i + 1) % length == 0:
                sys.stdout.write(str(data[i]) + '\n')
                main_board_string += str(data[i] + '\n')
                counter += 1
            else:
                sys.stdout.write(str(data[i]) + ' ')
                main_board_string += str(data[i]) + ' '
            sys.stdout.flush()
        return main_board_string

    def main_board_matrix(data):
        data = data.rstrip()
        main_matrix = []
        for i in data.split('\n'):
            main_matrix.append(i.split())
        return main_matrix

    def check_win(data):
        def col_check():
            nonlocal data
            cols = []
            for index in range(len(data[0])):
                cols.append([data[0][index]])
                for row in data[1:]:
                    cols[index] += [row[index]]
            for col in cols:
                player = list(set(col))[0]
                if len(set(col)) == 1 and player != '_':
                    return True, player

        def row_check():
            nonlocal data
            for row in data:
                player = list(set(row))[0]
                if len(set(row)) == 1 and player != '_':
                    return True, player

        def diagonal_check():
            counter, right_diagonal = 0, []
            nonlocal data
            for row in data:
                right_diagonal.append(row[counter])
                counter += 1
            player = list(set(right_diagonal))[0]
            if len(set(right_diagonal)) == 1 and player != '_':
                return True, player
            counter, left_diagonal = 0, []
            for row in data:
                left_diagonal.append(row[-counter])
                counter += 1
            player = list(set(left_diagonal))[0]
            if len(set(left_diagonal)) == 1 and player != '_':
                return True, player
        rows_check = row_check()
        cols_check = col_check()
        diagonal_check = diagonal_check()
        if rows_check:
            return rows_check[1]
        elif cols_check:
            return cols_check[1]
        elif diagonal_check:
            return diagonal_check[1]
    if gamer_choice.upper() == 'X' or gamer_choice.upper() == 'O':
        del available_choices[available_choices.index(gamer_choice.lower())]
        print('[+] The game started.')
        while non_used_cells:
            try:
                player_choice = int(input('[+] Please Enter Cell Number %s: ' % non_used_cells))
                if player_choice not in non_used_cells:
                    print('[+] Please Enter Valid Cell Number. Game will stop')
                    os._exit(1)
            except ValueError:
                print('[+] Please Enter Valid Cell Number. Game will stop')
                os._exit(1)
            else:
                if 1 <= player_choice <= 9:
                    cells[player_choice-1] = gamer_choice
                    del non_used_cells[non_used_cells.index(player_choice)]
                    if non_used_cells:
                        computer_choice = random.choice(non_used_cells)
                        cells[computer_choice - 1] = available_choices[0]
                        del non_used_cells[non_used_cells.index(computer_choice)]
                    checker = check_win(main_board_matrix(print_matrix(cells)))
                    if checker:
                        print("%s Has win" % checker)
                        break
                else:
                    print('[+] Please Enter Valid Cell Number. Game will stop')
    else:
        os.system('clear') if not sys.platform.__contains__('win') else os.system('clear')
        simple_game()

def find_prime_kPerm(n, kPerm):
    from itertools import permutations as perm
    def is_prime(number):
        for i in range(2, number):
            if number % i == 0 and not number == 2:
                return False
        return True
    primes = [x for x in range(12, n+1) if is_prime(x)]
    res = []
    for i in primes:
        required_perm = [int(''.join(list(x))) for x in perm(str(i))]
        required_perm = [x for x in required_perm if is_prime(x) and x != i and len(str(x)) == len(str(i))]
        if len(required_perm) == kPerm:
            res += [i]
    if len(res) == 0:
        return [0, 0, 0]
    else:
        return [len(res), min(res), max(res)]

def skrzat(base, number):
    if base == 'b':
        number = number[::-1]
        decoded_number = 0
        for i in range(len(number)):
            decoded_number += ((-2)**i) * int(number[i])
        return 'From binary: %s is %s' % (number[::-1], decoded_number)
    elif base == 'd':
        x = number
        if number == 0:
            return "0"
        converted_number = ""
        while number != 0:
            remainder = number % -2
            number //= -2
            if remainder < 0:
                remainder += 2
                number += 1
            converted_number += str(abs(remainder))
        return "From decimal: %s is %s" % (x, converted_number[::-1])
    else:
        return None
    pass
def knights_tour(start, size):
    import time, copy

    def make_board(size):
        return {(x, y): 0 for x in range(1, size+1) for y in range(1, size+1)}
    my_board = make_board(size)
    my_board[tuple(start)] = 1
    moves = [tuple(start)]
    next_move = start
    knight_moves = ((1, 2), (-1, 2), (2, 1), (-2, 1), (2, -1), (-2, -1), (-1, -2), (1, -2))

    def make_string_from_board(my_board):
        board = []
        for row in range(size):
            board += [[]]
            for column in range(size):
                board[row] += [my_board[(column+1, row+1)]]
        return board
    def avail_moves(point, board):
        return set((point[0]+_x, point[1]+_y) for _x, _y in knight_moves if (1 <= point[0]+_x <= size
                   and 1 <= point[1]+_y <= size) and not board[(point[0]+_x, point[1]+_y)])
    counter = 0

    def accessability(move):
        access = []
        board = copy.deepcopy(my_board)
        for position in avail_moves(move, board):
            board[position] = 1
            access.append((len(avail_moves(position, board)), position))
            board[position] = 0
        return access
    while counter < size * size:
        if accessability(next_move):
            next_move = min(accessability(next_move))[1]
            my_board[next_move] = 1
            moves += [next_move]
            counter += 1
        else:
            break
    print(*make_string_from_board(my_board))
    return moves


def sorting_algorithm(lst):
    main_list = []; [main_list.append(x) for x in lst if not x in main_list]
    sorted_array = []
    while main_list:
        smallest_number = main_list[0]
        for number in main_list[1:]:
            if number < smallest_number:
                smallest_number = number
        main_list.remove(smallest_number)
        sorted_array += [smallest_number]
    return sorted_array
def simple_assembler(program):
    to_be_excuted = [line.split(" ") for line in program.split("\n")]
    Done = []
    enteries = {}
    nov = lambda x: int(x) if str(x).replace("-", "").isnumeric() else int(enteries[x])
    while to_be_excuted:
        excuting = to_be_excuted.pop(0)
        Done += [excuting]
        if excuting[0] == "mov":
            enteries[excuting[1]] = nov(excuting[2])
        elif excuting[0] == "inc":
            enteries[excuting[1]] += 1
        elif excuting[0] == "dec":
            enteries[excuting[1]] -= 1
        elif excuting[0] == "jnz":
            if nov(excuting[2]) < 0:
                if enteries[excuting[1]] > 0:
                    to_be_excuted = Done[int(nov(excuting[2]))-1:] + to_be_excuted
                    Done = Done[:int(nov(excuting[2]))-1]
                else:
                    continue
            else:
                to_be_excuted = to_be_excuted[int(nov(excuting[2])):]
    return enteries 
def brainfuck_to_c(source_code):
    if source_code.count("[") == source_code.count("]"):
        while source_code.count("[]") > 0:
            source_code = source_code.replace("[]", "")
        data = dict(); identifier = 0; counter = 0
        for char in source_code:
            if char == "+" or char == '-' or char == '>' or char == '<':
                if counter != 0 and char != source_code[counter - 1]:
                    identifier += 1
                if (str(identifier), char) in data.keys():
                    data[(str(identifier), char)] += str(identifier)
                else:
                    data[(str(identifier), char)] = str(identifier)
            else:
                if (str(identifier), char) not in data.keys():
                    data[(str(identifier), char)] = str(identifier)
                else:
                    data[(str(identifier), char)] += str(identifier)
                    pass
                identifier += 1
            counter += 1
        def replacer(dictionary):
            translate_code = ""
            for (key, value) in dictionary.items():
                if key[1] == "+":
                    translate_code += "*p += %d;\n" % value.count(key[0])
                elif key[1] == '>':
                    translate_code += "p += %d;\n" % value.count(key[0])
                elif key[1] == '-':
                    translate_code += "*p -= %d;\n" % value.count(key[0])
                elif key[1] == '<':
                    translate_code += "p -= %d;\n" % value.count(key[0])
                elif key[1] == '.':
                    translate_code += "putchar(*p);\n"
                elif key[1] == ',':
                    translate_code += "*p = getchar();\n"
                elif key[1] == '[':
                    translate_code += "if (*p) do {\n"
                elif key[1] == ']':
                    translate_code += "} while (*p);\n"
            return translate_code
        return replacer(data)
    else:
        return "Error!"

print(brainfuck_to_c("++++[.++--]"))

class file_manager:
    import os
    def __init__(self, path):
        self.data = self.__Tree_dscanner(path)
        pass
    def __Tree_dscanner(self, path):
        data = {path:[]}
        for i in os.listdir(path):
            if os.path.isdir(i):
                data.update(self.__Tree_dscanner(i))
            else:
                data[path] += [i]
        return data
    def printpath(self):
        readable_data = ""
        for key in self.data:
            parser = "\n"
            for val in self.data[key]:
                parser += "   -"+str(val)+"\n"
            readable_data += "--dir ["+str(key)+"]"+parser
        return readable_data
    
class Infix:
    def __init__(self, function):
        self.function = function
    def __ror__(self, other):
        return Infix(lambda x, self=self, other=

def loading_bar(length=10, time_sleep: 'millisecond'=100, shape1='*', shape2='-'):
    import time, sys
    progress_bar = ""
    for i in range(length+1):
        if i % 2 == 0:
            progress_bar = "[%s%s][%s" % (i, '%', shape1 * i)
        else:
            progress_bar = "[%s%s][%s" % (i, '%', shape2 * i)
        sys.stdout.write(progress_bar)
        sys.stdout.flush()
        if i < length-1:
            time.sleep(time_sleep * (1e-3))
            sys.stdout.write('\r')
            sys.stdout.flush()
        else:
            sys.stdout.write('\r')
            sys.stdout.flush()
            sys.stdout.write(progress_bar)
    sys.stdout.write(']')
loading_bar(100, 500, '|')
def trailling_zeros(num):
	counter, start = 0, 5
	while int(num/start) >= 1:
		counter += int(num/start)
		start *= 5
	return counter
def set_variable(package_name, variable_name, variable_value):
	from sys import path as sys_path
	from os import path as os_path
	from os import listdir as list_dir
	for path in sys_path:
		if os_path.isdir(path):
			packages = [x for x in list_dir(path) if package_name == x.rsplit('.py')[0]]
			if len(packages) > 0:
				module_reader = open(os_path.join(path, packages[0]), 'r+')
				break
	else:
		return 'Module Not Found'
	data = module_reader.readlines()
	module_reader.seek(0)
	Found = False
	for line in data:
		if str(variable_name) + '=' in line.replace(' ', ''):
			splitted = line.replace(' ', '').split('=')
			splitted[splitted.index(variable_name) + 1] = repr(variable_value) if type(variable_value) == str else variable_value
			Found = True
			module_reader.write(' = '.join(splitted))
		else:
			module_reader.write(line)
		module_reader.truncate()
	if Found:
		return 'Variable changed successfully'
	else:
		return 'Variable cannot be found'
	module_reader.close()

def file_tree(path):
	import os
	path = os.path.realpath(path)
	path_data = {}
	if os.path.isdir(path):
		path_data[path] = []
		counter = 0
		for i in os.listdir(path):
			if os.path.isdir(os.path.join(path, i)):
				path_data[path].append({i: []})
				path_data[path][counter][i] = file_tree(os.path.join(path, i))
			else:
				path_data[path].append(i)
			counter += 1
		return path_data
	return path
exp = lambda x, y: x * exp(x, y-1) if y > 0 else 1
multiply = lambda x, y: x + multiply(x, y - 1) if y > 0 else 0
def f1(word):
	new_list, word, new_text = [word[0]], word[1:]+'x', ''
	while word:
		if new_list[-1] == word[0]:
			new_list += [word[0]]
			word = word[1:]
		else:
			new_text += '%s%s' % (new_list[-1], len(new_list))
			new_list, word = [word[0]], word[1:]
	return new_text
def f1(word):
	from string import ascii_letters
	new_dict = {key: str(word).count(key) for key in ascii_letters}
	return ''.join(['%s%s' % (key, val) if val > 0 else '' for key, val in new_dict.items()])
def formater(number):
	counter, decimal_chunk, new_number, number = 0, '', '', str(number)
	decimal_chunk = number.rsplit('.', 1)[-1] if '.' in number else ''
	number = number.replace(decimal_chunk, '').replace('.', '')
	for digit in number[::-1]:
		if counter < 2:
			new_number += digit
			counter += 1
		else:
			new_number += '%s,' % digit
			counter = 0
	return new_number[::-1] + '.' + decimal_chunk if decimal_chunk else new_number[::-1]
	
