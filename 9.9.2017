class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
primes = lambda n: [x for x in range(2, n+1) if x >= 2 and (len([x for check in range(2, x) if (x % check == 0 and check != x)]) == 0)]
def interpreter(code, tape):
    result = tape
    def icot(code=code):
        opening_tag = dict()
        op_tag = []
        sub_counter = 0
        for command in code:
            if command == '[':
                op_tag += [sub_counter]
            elif command == ']':
                opening_tag[op_tag.pop()] = sub_counter
            sub_counter += 1
        return opening_tag
    tape_counter = 0
    command_counter = 0
    command_freeze = False
    tags = icot()
    while 0 <= tape_counter < len(tape) and 0 <=  command_counter < len(code):
        command = code[command_counter]
        if command == '>':
            command_counter += 1
            tape_counter += 1
        elif command == '<':
            command_counter += 1
            tape_counter -= 1
        elif command == '*':
            if 0 <= tape_counter < len(result):
                result = list(result)
                if result[tape_counter] == '0':
                    result[tape_counter] = '1'
                else:
                    result[tape_counter] = '0'
                result = ''.join(result)
            else:
                return result
            command_counter += 1
        elif command == '[':
            tags[tags[command_counter]] = command_counter
            if result[tape_counter] == '0':
                command_counter = tags[command_counter]
            else:
                command_counter += 1
        elif command == ']':
            if result[tape_counter] == '1':
                command_counter = tags[command_counter]
            else:
                command_counter += 1
        else:
            command_counter += 1
    return result
    
def find_prime_kPerm(n, kPerm):
    from itertools import permutations as perm
    def is_prime(number):
        for i in range(2, number):
            if number % i == 0 and not number == 2:
                return False
        return True
    primes = [x for x in range(12, n+1) if is_prime(x)]
    res = []
    for i in primes:
        required_perm = [int(''.join(list(x))) for x in perm(str(i))]
        required_perm = [x for x in required_perm if is_prime(x) and x != i and len(str(x)) == len(str(i))]
        if len(required_perm) == kPerm:
            res += [i]
    if len(res) == 0:
        return [0, 0, 0]
    else:
        return [len(res), min(res), max(res)]

def skrzat(base, number):
    if base == 'b':
        number = number[::-1]
        decoded_number = 0
        for i in range(len(number)):
            decoded_number += ((-2)**i) * int(number[i])
        return 'From binary: %s is %s' % (number[::-1], decoded_number)
    elif base == 'd':
        x = number
        if number == 0:
            return "0"
        converted_number = ""
        while number != 0:
            remainder = number % -2
            number //= -2
            if remainder < 0:
                remainder += 2
                number += 1
            converted_number += str(abs(remainder))
        return "From decimal: %s is %s" % (x, converted_number[::-1])
    else:
        return None
    pass
def knights_tour(start, size):
    import time, copy

    def make_board(size):
        return {(x, y): 0 for x in range(1, size+1) for y in range(1, size+1)}
    my_board = make_board(size)
    my_board[tuple(start)] = 1
    moves = [tuple(start)]
    next_move = start
    knight_moves = ((1, 2), (-1, 2), (2, 1), (-2, 1), (2, -1), (-2, -1), (-1, -2), (1, -2))

    def make_string_from_board(my_board):
        board = []
        for row in range(size):
            board += [[]]
            for column in range(size):
                board[row] += [my_board[(column+1, row+1)]]
        return board
    def avail_moves(point, board):
        return set((point[0]+_x, point[1]+_y) for _x, _y in knight_moves if (1 <= point[0]+_x <= size
                   and 1 <= point[1]+_y <= size) and not board[(point[0]+_x, point[1]+_y)])
    counter = 0

    def accessability(move):
        access = []
        board = copy.deepcopy(my_board)
        for position in avail_moves(move, board):
            board[position] = 1
            access.append((len(avail_moves(position, board)), position))
            board[position] = 0
        return access
    while counter < size * size:
        if accessability(next_move):
            next_move = min(accessability(next_move))[1]
            my_board[next_move] = 1
            moves += [next_move]
            counter += 1
        else:
            break
    print(*make_string_from_board(my_board))
    return moves


def sorting_algorithm(lst):
    main_list = []; [main_list.append(x) for x in lst if not x in main_list]
    sorted_array = []
    while main_list:
        smallest_number = main_list[0]
        for number in main_list[1:]:
            if number < smallest_number:
                smallest_number = number
        main_list.remove(smallest_number)
        sorted_array += [smallest_number]
    return sorted_array
def simple_assembler(program):
    to_be_excuted = [line.split(" ") for line in program.split("\n")]
    Done = []
    enteries = {}
    nov = lambda x: int(x) if str(x).replace("-", "").isnumeric() else int(enteries[x])
    while to_be_excuted:
        excuting = to_be_excuted.pop(0)
        Done += [excuting]
        if excuting[0] == "mov":
            enteries[excuting[1]] = nov(excuting[2])
        elif excuting[0] == "inc":
            enteries[excuting[1]] += 1
        elif excuting[0] == "dec":
            enteries[excuting[1]] -= 1
        elif excuting[0] == "jnz":
            if nov(excuting[2]) < 0:
                if enteries[excuting[1]] > 0:
                    to_be_excuted = Done[int(nov(excuting[2]))-1:] + to_be_excuted
                    Done = Done[:int(nov(excuting[2]))-1]
                else:
                    continue
            else:
                to_be_excuted = to_be_excuted[int(nov(excuting[2])):]
    return enteries 
def brainfuck_to_c(source_code):
    if source_code.count("[") == source_code.count("]"):
        while source_code.count("[]") > 0:
            source_code = source_code.replace("[]", "")
        data = dict(); identifier = 0; counter = 0
        for char in source_code:
            if char == "+" or char == '-' or char == '>' or char == '<':
                if counter != 0 and char != source_code[counter - 1]:
                    identifier += 1
                if (str(identifier), char) in data.keys():
                    data[(str(identifier), char)] += str(identifier)
                else:
                    data[(str(identifier), char)] = str(identifier)
            else:
                if (str(identifier), char) not in data.keys():
                    data[(str(identifier), char)] = str(identifier)
                else:
                    data[(str(identifier), char)] += str(identifier)
                    pass
                identifier += 1
            counter += 1
        def replacer(dictionary):
            translate_code = ""
            for (key, value) in dictionary.items():
                if key[1] == "+":
                    translate_code += "*p += %d;\n" % value.count(key[0])
                elif key[1] == '>':
                    translate_code += "p += %d;\n" % value.count(key[0])
                elif key[1] == '-':
                    translate_code += "*p -= %d;\n" % value.count(key[0])
                elif key[1] == '<':
                    translate_code += "p -= %d;\n" % value.count(key[0])
                elif key[1] == '.':
                    translate_code += "putchar(*p);\n"
                elif key[1] == ',':
                    translate_code += "*p = getchar();\n"
                elif key[1] == '[':
                    translate_code += "if (*p) do {\n"
                elif key[1] == ']':
                    translate_code += "} while (*p);\n"
            return translate_code
        return replacer(data)
    else:
        return "Error!"

print(brainfuck_to_c("++++[.++--]"))

class file_manager:
    import os
    def __init__(self, path):
        self.data = self.__Tree_dscanner(path)
        pass
    def __Tree_dscanner(self, path):
        data = {path:[]}
        for i in os.listdir(path):
            if os.path.isdir(i):
                data.update(self.__Tree_dscanner(i))
            else:
                data[path] += [i]
        return data
    def printpath(self):
        readable_data = ""
        for key in self.data:
            parser = "\n"
            for val in self.data[key]:
                parser += "   -"+str(val)+"\n"
            readable_data += "--dir ["+str(key)+"]"+parser
        return readable_data
    
class Infix:
    def __init__(self, function):
        self.function = function
    def __ror__(self, other):
        return Infix(lambda x, self=self, other=

def loading_bar(length=10, time_sleep: 'millisecond'=100, shape1='*', shape2='-'):
    import time, sys
    progress_bar = ""
    for i in range(length+1):
        if i % 2 == 0:
            progress_bar = "[%s%s][%s" % (i, '%', shape1 * i)
        else:
            progress_bar = "[%s%s][%s" % (i, '%', shape2 * i)
        sys.stdout.write(progress_bar)
        sys.stdout.flush()
        if i < length-1:
            time.sleep(time_sleep * (1e-3))
            sys.stdout.write('\r')
            sys.stdout.flush()
        else:
            sys.stdout.write('\r')
            sys.stdout.flush()
            sys.stdout.write(progress_bar)
    sys.stdout.write(']')
loading_bar(100, 500, '|')
fact = lambda x: 1 if x == 0 else x * fact(x-1)
def trailling_zeros(num):
	counter, start = 0, 5
	while int(num/start) >= 1:
		counter += int(num/start)
		start *= 5
	return counter
